#!/usr/bin/env rundklet
register_net
register :appname, 'pg'

# TODO fix production safety!
register :initpassword, 'password'
register :dbapassword,  'dbapassword'

write_dockerfile <<~Desc
  FROM postgres:9.6-alpine
  LABEL <%=image_labels%>
  USER postgres
  ADD entrypoint-initdb.d /docker-entrypoint-initdb.d
Desc

before_task :build do
  pswd = fetch(:dbapassword)
  tmpl = <<~Desc
    --generated by dklet
    CREATE USER dbauser with superuser password '#{pswd}';
  Desc
  erb = ERB.new(tmpl, nil, '%<>')
  rendered = erb.result(binding)
  
  file = script_path.join('entrypoint-initdb.d/init.sql')
  file.write(rendered)
  puts "==update file: #{file}"
end

task :main do
  system <<~Desc
    #{dkrun_cmd(named: true)} -d #{'--restart always' if env == 'prod'} \
      -p #{host_port}:5432 \
      -e POSTGRES_PASSWORD=#{fetch(:initpassword)} \
      -v "#{script_path}/conf/postgresql.conf":/etc/postgresql/postgresql.conf \
      -v "#{app_volumes}":/var/lib/postgresql/data \
      #{docker_image} -c 'config_file=/etc/postgresql/postgresql.conf'
      # -c 'shared_buffers=256MB' -c 'max_connections=200'
  Desc
  
  t0 = Time.now
  until system("docker exec #{ops_container} pg_isready > /dev/null")
    puts "waiting for initdb..."
    sleep 1
  end
  puts "wait taken #{Time.now - t0} seconds"
end

custom_commands do
  desc 'psql', ''
  def psql(*args)
    container_run "psql -a #{args.join(' ')}"
  end

  desc '', 'reset if need'
  def reset
    # be careful
    abort "Not support reset for #{env}" if env != 'dev'
    system <<~Desc
      #{dklet_script} clean
      #{dklet_script} clear_app_volumes
      #{dklet_script}
    Desc
  end

  desc 'sampleconf', ''
  def sampleconf
    # debian /usr/share/postgresql/postgresql.conf.sample
    system <<~Desc
      #{dktmprun} cat /usr/local/share/postgresql/postgresql.conf.sample | tee #{script_path}/conf/postgresql.conf.sample
      #{dktmprun} cat /usr/local/share/postgresql/pg_hba.conf.sample | tee #{script_path}/conf/pg_hba.conf.sample
    Desc
  end

  desc 'entrypoint', 'show entrypoint'
  def entrypoint
    system <<~Desc
      #{dktmprun} cat docker-entrypoint.sh
    Desc
  end
 
  desc 'user', ''
  def users
    container_run <<~Desc
      psql -c '\\du'
    Desc
  end

  desc 'create_user USER PASSWORD', 'create a dbuser for app eg. rails'
  def create_user(user, passwd)
    container_run <<~Desc
      cat <<-SQL | psql
        CREATE USER #{user} with CREATEDB PASSWORD '#{passwd}';
      SQL
    Desc
  end

  desc '', 'test if password changed after inited'
  def change_password_reboot
    cname = 'pgpswd1'
    pswd = fetch(:initpassword)
    pswd1 = "#{pswd}-changed"
    system <<~Desc
      docker rm -f #{cname}
      #{dkrun_cmd} -d --name #{cname} -p :5432 \
        -e POSTGRES_PASSWORD=#{pswd1} \
        -v "#{app_volumes}":/var/lib/postgresql/data \
        #{docker_image}
    Desc
    
    t0 = Time.now
    until system("docker exec #{cname} pg_isready > /dev/null")
      puts "waiting for initdb..."
      sleep 1
    end
    puts "wait taken #{Time.now - t0} seconds"

    # use different password to startup, no effect 
    container_run <<~Desc, tmp: true
      psql -c 'show work_mem' postgres://postgres:#{pswd1}@#{cname}/postgres
    Desc
    ## ok, keep old init password 
    container_run <<~Desc, tmp: true
      psql -c 'show work_mem' postgres://postgres:#{pswd}@#{cname}/postgres
    Desc
  end
  
  no_commands do
    def host_port
      case env
      when 'prod'
        '15432' 
      else
        '25432' 
      end
    end
  end
end

__END__

try master-slave cluster

healthcheck https://github.com/docker-library/healthcheck/blob/master/postgres/docker-healthcheck

drop user "v-token-readonly-55wami8rM5M7vSewJuFC-1540458739";
